---
interface Props {
  scenario: any; // Using any for now to avoid extensive import cycles, or import Schema
}

const { scenario } = Astro.props;
---

<div class="chat-container">
    <div id="messages-list" class="messages-list">
        <!-- Messages will be injected here -->
    </div>

    <div id="options-area" class="options-area hidden">
        <!-- Options will be injected here -->
    </div>
    
    <div id="continue-area" class="continue-area hidden">
       <button id="continue-btn" class="btn-continue">Continuar â–¼</button>
    </div>
</div>

<script define:vars={{ scenario }}>
    import { userProgress, saveProgress, completeScenario } from '../lib/storage';

    // DOM Elements
    const messagesList = document.getElementById('messages-list');
    const optionsArea = document.getElementById('options-area');
    const continueArea = document.getElementById('continue-area');
    const continueBtn = document.getElementById('continue-btn');

    // State
    let currentNodeId = scenario.initial_node_id;
    let isTyping = false;

    // Initialize from storage if exists
    const progress = userProgress.get();
    if (progress.scenarioProgress && progress.scenarioProgress[scenario.id]) {
        // We could restore history here if we saved it, 
        // for now just jump to the last node.
        // But for a better UX, maybe we should restart if the node is not found?
        // Let's assume we start at the saved node.
        currentNodeId = progress.scenarioProgress[scenario.id];
    }
    
    // Check if scenario has nodes (sanity check)
    if (!scenario.nodes[currentNodeId]) {
        console.warn('Node not found, resetting to start');
        currentNodeId = scenario.initial_node_id;
    }

    // --- Core Functions ---

    function renderMessage(node) {
        if (!node) return;
        
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${node.sender}`;
        
        // Simple Markdown-ish parser (bold)
        const text = node.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        msgDiv.innerHTML = `
            <div class="bubble">${text}</div>
        `;
        
        messagesList.appendChild(msgDiv);
        scrollToBottom();
        
        // Handle Action
        if (node.action) {
            handleAction(node.action, node.action_data);
        }
        
        // Handle Flow
        if (node.options && node.options.length > 0) {
            renderOptions(node.options);
        } else if (node.next_node_id) {
            showContinue(node.next_node_id);
        } else {
            // End of scenario logic
            handleEnd();
        }
        
        // Save state
        saveProgress(scenario.id, node.id);
    }

    function renderOptions(options) {
        optionsArea.innerHTML = '';
        optionsArea.classList.remove('hidden');
        continueArea.classList.add('hidden');
        
        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.className = `btn-option ${opt.style || 'default'}`;
            btn.textContent = opt.label;
            btn.onclick = () => {
                // User message (echo choice)
                const echoNode = { 
                    sender: 'user', 
                    text: opt.label, 
                    id: 'user-echo-' + Date.now() 
                };
                renderMessage(echoNode);
                
                // Hide options
                optionsArea.classList.add('hidden');
                
                // Next node
                const nextNode = scenario.nodes[opt.next_node_id];
                setTimeout(() => renderMessage(nextNode), 500);
            };
            optionsArea.appendChild(btn);
        });
        scrollToBottom();
    }
    
    function showContinue(nextId) {
        continueArea.classList.remove('hidden');
        continueBtn.onclick = () => {
            continueArea.classList.add('hidden');
            const nextNode = scenario.nodes[nextId];
            renderMessage(nextNode);
            continueBtn.onclick = null; // cleanup
        };
        scrollToBottom();
    }
    
    function handleAction(action, data) {
        // Dispatch custom event for other components (like Friend.astro)
        const event = new CustomEvent('kidia:action', { 
            detail: { action, data } 
        });
        window.dispatchEvent(event);
    }
    
    function handleEnd() {
        console.log('Scenario Completed');
        completeScenario(scenario.id);
        
        // Show completion message
        const endDiv = document.createElement('div');
        endDiv.className = 'message system';
        endDiv.innerHTML = `<div class="bubble system-bubble">Â¡Escenario Completado! ðŸŽ‰</div>`;
        messagesList.appendChild(endDiv);
        
        // Trigger Quiz open
        setTimeout(() => {
             const event = new CustomEvent('startQuiz', {
                 detail: { scenarioId: scenario.id }
             });
             window.dispatchEvent(event);
        }, 1500);
    }
    
    function scrollToBottom() {
        // Using a timeout to ensure DOM render
        setTimeout(() => {
             const last = messagesList.lastElementChild;
             if(last) last.scrollIntoView({ behavior: 'smooth' });
        }, 50);
    }

    // --- Init ---
    // Start with the current node
    const startNode = scenario.nodes[currentNodeId];
    renderMessage(startNode);

</script>

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        max-height: 600px;
        background: rgba(0,0,0,0.2);
        border-radius: 1rem;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.1);
    }
    
    .messages-list {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .message {
        display: flex;
        width: 100%;
    }
    
    .message.kidia { justify-content: flex-start; }
    .message.user { justify-content: flex-end; }
    .message.system { justify-content: center; }
    
    .bubble {
        max-width: 80%;
        padding: 1rem 1.2rem;
        border-radius: 1rem;
        font-size: 1.1rem;
        line-height: 1.5;
        position: relative;
    }
    
    .kidia .bubble {
        background: var(--color-surface);
        border-bottom-left-radius: 0.2rem;
        border: 1px solid rgba(255,255,255,0.1);
        color: #fff;
    }
    
    .user .bubble {
        background: var(--color-primary);
        border-bottom-right-radius: 0.2rem;
        color: #000;
        font-weight: 500;
    }
    
    .system-bubble {
        background: #F59E0B; /* Amber */
        color: black;
        font-weight: bold;
        text-align: center;
        border-radius: 2rem;
        font-size: 0.9rem;
    }
    
    .options-area {
        padding: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        background: rgba(0,0,0,0.3);
        justify-content: center;
        min-height: 80px;
    }
    
    .continue-area {
        padding: 1rem;
        display: flex;
        justify-content: center;
        background: rgba(0,0,0,0.1);
    }
    
    .btn-option {
        padding: 0.8rem 1.5rem;
        border-radius: 2rem;
        border: 1px solid var(--color-primary);
        background: transparent;
        color: var(--color-primary);
        cursor: pointer;
        transition: all 0.2s;
        font-size: 1rem;
    }
    
    .btn-option:hover {
        background: var(--color-primary);
        color: #000;
        transform: translateY(-2px);
    }
    
    .btn-continue {
        background: transparent;
        border: none;
        color: rgba(255,255,255,0.5);
        cursor: pointer;
        animation: pulse 2s infinite;
    }
    
    .hidden {
        display: none !important;
    }
</style>
